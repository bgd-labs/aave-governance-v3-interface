/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace IVotingMachineWithProofs {
  export type ProposalWithoutVotesStruct = {
    id: PromiseOrValue<BigNumberish>;
    sentToGovernance: PromiseOrValue<boolean>;
    startTime: PromiseOrValue<BigNumberish>;
    endTime: PromiseOrValue<BigNumberish>;
    votingClosedAndSentTimestamp: PromiseOrValue<BigNumberish>;
    forVotes: PromiseOrValue<BigNumberish>;
    againstVotes: PromiseOrValue<BigNumberish>;
    creationBlockNumber: PromiseOrValue<BigNumberish>;
    votingClosedAndSentBlockNumber: PromiseOrValue<BigNumberish>;
  };

  export type ProposalWithoutVotesStructOutput = [
    BigNumber,
    boolean,
    number,
    number,
    number,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    id: BigNumber;
    sentToGovernance: boolean;
    startTime: number;
    endTime: number;
    votingClosedAndSentTimestamp: number;
    forVotes: BigNumber;
    againstVotes: BigNumber;
    creationBlockNumber: BigNumber;
    votingClosedAndSentBlockNumber: BigNumber;
  };

  export type ProposalVoteConfigurationStruct = {
    votingDuration: PromiseOrValue<BigNumberish>;
    l1ProposalBlockHash: PromiseOrValue<BytesLike>;
  };

  export type ProposalVoteConfigurationStructOutput = [number, string] & {
    votingDuration: number;
    l1ProposalBlockHash: string;
  };

  export type VoteStruct = {
    support: PromiseOrValue<boolean>;
    votingPower: PromiseOrValue<BigNumberish>;
  };

  export type VoteStructOutput = [boolean, BigNumber] & {
    support: boolean;
    votingPower: BigNumber;
  };

  export type VotingBalanceProofStruct = {
    underlyingAsset: PromiseOrValue<string>;
    slot: PromiseOrValue<BigNumberish>;
    proof: PromiseOrValue<BytesLike>;
  };

  export type VotingBalanceProofStructOutput = [string, BigNumber, string] & {
    underlyingAsset: string;
    slot: BigNumber;
    proof: string;
  };

  export type SignatureParamsStruct = {
    v: PromiseOrValue<BigNumberish>;
    r: PromiseOrValue<BytesLike>;
    s: PromiseOrValue<BytesLike>;
  };

  export type SignatureParamsStructOutput = [number, string, string] & {
    v: number;
    r: string;
    s: string;
  };
}

export interface IVotingMachineWithProofsInterface extends utils.Interface {
  functions: {
    "DATA_WAREHOUSE()": FunctionFragment;
    "DOMAIN_SEPARATOR()": FunctionFragment;
    "GOVERNANCE()": FunctionFragment;
    "NAME()": FunctionFragment;
    "REPRESENTATIVES_SLOT()": FunctionFragment;
    "VOTE_SUBMITTED_BY_REPRESENTATIVE_TYPEHASH()": FunctionFragment;
    "VOTE_SUBMITTED_TYPEHASH()": FunctionFragment;
    "VOTING_ASSET_WITH_SLOT_RAW()": FunctionFragment;
    "VOTING_ASSET_WITH_SLOT_TYPEHASH()": FunctionFragment;
    "VOTING_STRATEGY()": FunctionFragment;
    "closeAndSendVote(uint256)": FunctionFragment;
    "getProposalById(uint256)": FunctionFragment;
    "getProposalState(uint256)": FunctionFragment;
    "getProposalVoteConfiguration(uint256)": FunctionFragment;
    "getProposalsVoteConfigurationIds(uint256,uint256)": FunctionFragment;
    "getUserProposalVote(address,uint256)": FunctionFragment;
    "startProposalVote(uint256)": FunctionFragment;
    "submitVote(uint256,bool,(address,uint128,bytes)[])": FunctionFragment;
    "submitVoteAsRepresentative(uint256,bool,address,bytes,(address,uint128,bytes)[])": FunctionFragment;
    "submitVoteAsRepresentativeBySignature(uint256,address,address,bool,bytes,(address,uint128,bytes)[],(uint8,bytes32,bytes32))": FunctionFragment;
    "submitVoteBySignature(uint256,address,bool,(address,uint128,bytes)[],uint8,bytes32,bytes32)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "DATA_WAREHOUSE"
      | "DOMAIN_SEPARATOR"
      | "GOVERNANCE"
      | "NAME"
      | "REPRESENTATIVES_SLOT"
      | "VOTE_SUBMITTED_BY_REPRESENTATIVE_TYPEHASH"
      | "VOTE_SUBMITTED_TYPEHASH"
      | "VOTING_ASSET_WITH_SLOT_RAW"
      | "VOTING_ASSET_WITH_SLOT_TYPEHASH"
      | "VOTING_STRATEGY"
      | "closeAndSendVote"
      | "getProposalById"
      | "getProposalState"
      | "getProposalVoteConfiguration"
      | "getProposalsVoteConfigurationIds"
      | "getUserProposalVote"
      | "startProposalVote"
      | "submitVote"
      | "submitVoteAsRepresentative"
      | "submitVoteAsRepresentativeBySignature"
      | "submitVoteBySignature"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "DATA_WAREHOUSE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "DOMAIN_SEPARATOR",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "GOVERNANCE",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "NAME", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "REPRESENTATIVES_SLOT",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "VOTE_SUBMITTED_BY_REPRESENTATIVE_TYPEHASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "VOTE_SUBMITTED_TYPEHASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "VOTING_ASSET_WITH_SLOT_RAW",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "VOTING_ASSET_WITH_SLOT_TYPEHASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "VOTING_STRATEGY",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "closeAndSendVote",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getProposalById",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getProposalState",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getProposalVoteConfiguration",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getProposalsVoteConfigurationIds",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserProposalVote",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "startProposalVote",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "submitVote",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      IVotingMachineWithProofs.VotingBalanceProofStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "submitVoteAsRepresentative",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      IVotingMachineWithProofs.VotingBalanceProofStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "submitVoteAsRepresentativeBySignature",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BytesLike>,
      IVotingMachineWithProofs.VotingBalanceProofStruct[],
      IVotingMachineWithProofs.SignatureParamsStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "submitVoteBySignature",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      IVotingMachineWithProofs.VotingBalanceProofStruct[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "DATA_WAREHOUSE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "DOMAIN_SEPARATOR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "GOVERNANCE", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "NAME", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "REPRESENTATIVES_SLOT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "VOTE_SUBMITTED_BY_REPRESENTATIVE_TYPEHASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "VOTE_SUBMITTED_TYPEHASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "VOTING_ASSET_WITH_SLOT_RAW",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "VOTING_ASSET_WITH_SLOT_TYPEHASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "VOTING_STRATEGY",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "closeAndSendVote",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProposalById",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProposalState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProposalVoteConfiguration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProposalsVoteConfigurationIds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserProposalVote",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "startProposalVote",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "submitVote", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "submitVoteAsRepresentative",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submitVoteAsRepresentativeBySignature",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submitVoteBySignature",
    data: BytesLike
  ): Result;

  events: {
    "ProposalResultsSent(uint256,uint256,uint256)": EventFragment;
    "ProposalVoteConfigurationBridged(uint256,bytes32,uint24,bool)": EventFragment;
    "ProposalVoteStarted(uint256,bytes32,uint256,uint256)": EventFragment;
    "VoteEmitted(uint256,address,bool,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ProposalResultsSent"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "ProposalVoteConfigurationBridged"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalVoteStarted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VoteEmitted"): EventFragment;
}

export interface ProposalResultsSentEventObject {
  proposalId: BigNumber;
  forVotes: BigNumber;
  againstVotes: BigNumber;
}
export type ProposalResultsSentEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber],
  ProposalResultsSentEventObject
>;

export type ProposalResultsSentEventFilter =
  TypedEventFilter<ProposalResultsSentEvent>;

export interface ProposalVoteConfigurationBridgedEventObject {
  proposalId: BigNumber;
  blockHash: string;
  votingDuration: number;
  voteCreated: boolean;
}
export type ProposalVoteConfigurationBridgedEvent = TypedEvent<
  [BigNumber, string, number, boolean],
  ProposalVoteConfigurationBridgedEventObject
>;

export type ProposalVoteConfigurationBridgedEventFilter =
  TypedEventFilter<ProposalVoteConfigurationBridgedEvent>;

export interface ProposalVoteStartedEventObject {
  proposalId: BigNumber;
  l1BlockHash: string;
  startTime: BigNumber;
  endTime: BigNumber;
}
export type ProposalVoteStartedEvent = TypedEvent<
  [BigNumber, string, BigNumber, BigNumber],
  ProposalVoteStartedEventObject
>;

export type ProposalVoteStartedEventFilter =
  TypedEventFilter<ProposalVoteStartedEvent>;

export interface VoteEmittedEventObject {
  proposalId: BigNumber;
  voter: string;
  support: boolean;
  votingPower: BigNumber;
}
export type VoteEmittedEvent = TypedEvent<
  [BigNumber, string, boolean, BigNumber],
  VoteEmittedEventObject
>;

export type VoteEmittedEventFilter = TypedEventFilter<VoteEmittedEvent>;

export interface IVotingMachineWithProofs extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IVotingMachineWithProofsInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    DATA_WAREHOUSE(overrides?: CallOverrides): Promise<[string]>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;

    GOVERNANCE(overrides?: CallOverrides): Promise<[string]>;

    NAME(overrides?: CallOverrides): Promise<[string]>;

    REPRESENTATIVES_SLOT(overrides?: CallOverrides): Promise<[BigNumber]>;

    VOTE_SUBMITTED_BY_REPRESENTATIVE_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<[string]>;

    VOTE_SUBMITTED_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    VOTING_ASSET_WITH_SLOT_RAW(overrides?: CallOverrides): Promise<[string]>;

    VOTING_ASSET_WITH_SLOT_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<[string]>;

    VOTING_STRATEGY(overrides?: CallOverrides): Promise<[string]>;

    closeAndSendVote(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getProposalById(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[IVotingMachineWithProofs.ProposalWithoutVotesStructOutput]>;

    getProposalState(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[number]>;

    getProposalVoteConfiguration(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [IVotingMachineWithProofs.ProposalVoteConfigurationStructOutput]
    >;

    getProposalsVoteConfigurationIds(
      skip: PromiseOrValue<BigNumberish>,
      size: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    getUserProposalVote(
      user: PromiseOrValue<string>,
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[IVotingMachineWithProofs.VoteStructOutput]>;

    startProposalVote(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    submitVote(
      proposalId: PromiseOrValue<BigNumberish>,
      support: PromiseOrValue<boolean>,
      votingBalanceProofs: IVotingMachineWithProofs.VotingBalanceProofStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    submitVoteAsRepresentative(
      proposalId: PromiseOrValue<BigNumberish>,
      support: PromiseOrValue<boolean>,
      voter: PromiseOrValue<string>,
      proofOfRepresentation: PromiseOrValue<BytesLike>,
      votingBalanceProofs: IVotingMachineWithProofs.VotingBalanceProofStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    submitVoteAsRepresentativeBySignature(
      proposalId: PromiseOrValue<BigNumberish>,
      voter: PromiseOrValue<string>,
      representative: PromiseOrValue<string>,
      support: PromiseOrValue<boolean>,
      proofOfRepresentation: PromiseOrValue<BytesLike>,
      votingBalanceProofs: IVotingMachineWithProofs.VotingBalanceProofStruct[],
      signatureParams: IVotingMachineWithProofs.SignatureParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    submitVoteBySignature(
      proposalId: PromiseOrValue<BigNumberish>,
      voter: PromiseOrValue<string>,
      support: PromiseOrValue<boolean>,
      votingBalanceProofs: IVotingMachineWithProofs.VotingBalanceProofStruct[],
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  DATA_WAREHOUSE(overrides?: CallOverrides): Promise<string>;

  DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

  GOVERNANCE(overrides?: CallOverrides): Promise<string>;

  NAME(overrides?: CallOverrides): Promise<string>;

  REPRESENTATIVES_SLOT(overrides?: CallOverrides): Promise<BigNumber>;

  VOTE_SUBMITTED_BY_REPRESENTATIVE_TYPEHASH(
    overrides?: CallOverrides
  ): Promise<string>;

  VOTE_SUBMITTED_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  VOTING_ASSET_WITH_SLOT_RAW(overrides?: CallOverrides): Promise<string>;

  VOTING_ASSET_WITH_SLOT_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  VOTING_STRATEGY(overrides?: CallOverrides): Promise<string>;

  closeAndSendVote(
    proposalId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getProposalById(
    proposalId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<IVotingMachineWithProofs.ProposalWithoutVotesStructOutput>;

  getProposalState(
    proposalId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<number>;

  getProposalVoteConfiguration(
    proposalId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<IVotingMachineWithProofs.ProposalVoteConfigurationStructOutput>;

  getProposalsVoteConfigurationIds(
    skip: PromiseOrValue<BigNumberish>,
    size: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  getUserProposalVote(
    user: PromiseOrValue<string>,
    proposalId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<IVotingMachineWithProofs.VoteStructOutput>;

  startProposalVote(
    proposalId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  submitVote(
    proposalId: PromiseOrValue<BigNumberish>,
    support: PromiseOrValue<boolean>,
    votingBalanceProofs: IVotingMachineWithProofs.VotingBalanceProofStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  submitVoteAsRepresentative(
    proposalId: PromiseOrValue<BigNumberish>,
    support: PromiseOrValue<boolean>,
    voter: PromiseOrValue<string>,
    proofOfRepresentation: PromiseOrValue<BytesLike>,
    votingBalanceProofs: IVotingMachineWithProofs.VotingBalanceProofStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  submitVoteAsRepresentativeBySignature(
    proposalId: PromiseOrValue<BigNumberish>,
    voter: PromiseOrValue<string>,
    representative: PromiseOrValue<string>,
    support: PromiseOrValue<boolean>,
    proofOfRepresentation: PromiseOrValue<BytesLike>,
    votingBalanceProofs: IVotingMachineWithProofs.VotingBalanceProofStruct[],
    signatureParams: IVotingMachineWithProofs.SignatureParamsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  submitVoteBySignature(
    proposalId: PromiseOrValue<BigNumberish>,
    voter: PromiseOrValue<string>,
    support: PromiseOrValue<boolean>,
    votingBalanceProofs: IVotingMachineWithProofs.VotingBalanceProofStruct[],
    v: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BytesLike>,
    s: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    DATA_WAREHOUSE(overrides?: CallOverrides): Promise<string>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

    GOVERNANCE(overrides?: CallOverrides): Promise<string>;

    NAME(overrides?: CallOverrides): Promise<string>;

    REPRESENTATIVES_SLOT(overrides?: CallOverrides): Promise<BigNumber>;

    VOTE_SUBMITTED_BY_REPRESENTATIVE_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<string>;

    VOTE_SUBMITTED_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    VOTING_ASSET_WITH_SLOT_RAW(overrides?: CallOverrides): Promise<string>;

    VOTING_ASSET_WITH_SLOT_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    VOTING_STRATEGY(overrides?: CallOverrides): Promise<string>;

    closeAndSendVote(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    getProposalById(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<IVotingMachineWithProofs.ProposalWithoutVotesStructOutput>;

    getProposalState(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<number>;

    getProposalVoteConfiguration(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<IVotingMachineWithProofs.ProposalVoteConfigurationStructOutput>;

    getProposalsVoteConfigurationIds(
      skip: PromiseOrValue<BigNumberish>,
      size: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    getUserProposalVote(
      user: PromiseOrValue<string>,
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<IVotingMachineWithProofs.VoteStructOutput>;

    startProposalVote(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    submitVote(
      proposalId: PromiseOrValue<BigNumberish>,
      support: PromiseOrValue<boolean>,
      votingBalanceProofs: IVotingMachineWithProofs.VotingBalanceProofStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    submitVoteAsRepresentative(
      proposalId: PromiseOrValue<BigNumberish>,
      support: PromiseOrValue<boolean>,
      voter: PromiseOrValue<string>,
      proofOfRepresentation: PromiseOrValue<BytesLike>,
      votingBalanceProofs: IVotingMachineWithProofs.VotingBalanceProofStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    submitVoteAsRepresentativeBySignature(
      proposalId: PromiseOrValue<BigNumberish>,
      voter: PromiseOrValue<string>,
      representative: PromiseOrValue<string>,
      support: PromiseOrValue<boolean>,
      proofOfRepresentation: PromiseOrValue<BytesLike>,
      votingBalanceProofs: IVotingMachineWithProofs.VotingBalanceProofStruct[],
      signatureParams: IVotingMachineWithProofs.SignatureParamsStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    submitVoteBySignature(
      proposalId: PromiseOrValue<BigNumberish>,
      voter: PromiseOrValue<string>,
      support: PromiseOrValue<boolean>,
      votingBalanceProofs: IVotingMachineWithProofs.VotingBalanceProofStruct[],
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "ProposalResultsSent(uint256,uint256,uint256)"(
      proposalId?: PromiseOrValue<BigNumberish> | null,
      forVotes?: null,
      againstVotes?: null
    ): ProposalResultsSentEventFilter;
    ProposalResultsSent(
      proposalId?: PromiseOrValue<BigNumberish> | null,
      forVotes?: null,
      againstVotes?: null
    ): ProposalResultsSentEventFilter;

    "ProposalVoteConfigurationBridged(uint256,bytes32,uint24,bool)"(
      proposalId?: PromiseOrValue<BigNumberish> | null,
      blockHash?: PromiseOrValue<BytesLike> | null,
      votingDuration?: null,
      voteCreated?: PromiseOrValue<boolean> | null
    ): ProposalVoteConfigurationBridgedEventFilter;
    ProposalVoteConfigurationBridged(
      proposalId?: PromiseOrValue<BigNumberish> | null,
      blockHash?: PromiseOrValue<BytesLike> | null,
      votingDuration?: null,
      voteCreated?: PromiseOrValue<boolean> | null
    ): ProposalVoteConfigurationBridgedEventFilter;

    "ProposalVoteStarted(uint256,bytes32,uint256,uint256)"(
      proposalId?: PromiseOrValue<BigNumberish> | null,
      l1BlockHash?: PromiseOrValue<BytesLike> | null,
      startTime?: null,
      endTime?: null
    ): ProposalVoteStartedEventFilter;
    ProposalVoteStarted(
      proposalId?: PromiseOrValue<BigNumberish> | null,
      l1BlockHash?: PromiseOrValue<BytesLike> | null,
      startTime?: null,
      endTime?: null
    ): ProposalVoteStartedEventFilter;

    "VoteEmitted(uint256,address,bool,uint256)"(
      proposalId?: PromiseOrValue<BigNumberish> | null,
      voter?: PromiseOrValue<string> | null,
      support?: PromiseOrValue<boolean> | null,
      votingPower?: null
    ): VoteEmittedEventFilter;
    VoteEmitted(
      proposalId?: PromiseOrValue<BigNumberish> | null,
      voter?: PromiseOrValue<string> | null,
      support?: PromiseOrValue<boolean> | null,
      votingPower?: null
    ): VoteEmittedEventFilter;
  };

  estimateGas: {
    DATA_WAREHOUSE(overrides?: CallOverrides): Promise<BigNumber>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber>;

    GOVERNANCE(overrides?: CallOverrides): Promise<BigNumber>;

    NAME(overrides?: CallOverrides): Promise<BigNumber>;

    REPRESENTATIVES_SLOT(overrides?: CallOverrides): Promise<BigNumber>;

    VOTE_SUBMITTED_BY_REPRESENTATIVE_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    VOTE_SUBMITTED_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    VOTING_ASSET_WITH_SLOT_RAW(overrides?: CallOverrides): Promise<BigNumber>;

    VOTING_ASSET_WITH_SLOT_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    VOTING_STRATEGY(overrides?: CallOverrides): Promise<BigNumber>;

    closeAndSendVote(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getProposalById(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getProposalState(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getProposalVoteConfiguration(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getProposalsVoteConfigurationIds(
      skip: PromiseOrValue<BigNumberish>,
      size: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getUserProposalVote(
      user: PromiseOrValue<string>,
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    startProposalVote(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    submitVote(
      proposalId: PromiseOrValue<BigNumberish>,
      support: PromiseOrValue<boolean>,
      votingBalanceProofs: IVotingMachineWithProofs.VotingBalanceProofStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    submitVoteAsRepresentative(
      proposalId: PromiseOrValue<BigNumberish>,
      support: PromiseOrValue<boolean>,
      voter: PromiseOrValue<string>,
      proofOfRepresentation: PromiseOrValue<BytesLike>,
      votingBalanceProofs: IVotingMachineWithProofs.VotingBalanceProofStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    submitVoteAsRepresentativeBySignature(
      proposalId: PromiseOrValue<BigNumberish>,
      voter: PromiseOrValue<string>,
      representative: PromiseOrValue<string>,
      support: PromiseOrValue<boolean>,
      proofOfRepresentation: PromiseOrValue<BytesLike>,
      votingBalanceProofs: IVotingMachineWithProofs.VotingBalanceProofStruct[],
      signatureParams: IVotingMachineWithProofs.SignatureParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    submitVoteBySignature(
      proposalId: PromiseOrValue<BigNumberish>,
      voter: PromiseOrValue<string>,
      support: PromiseOrValue<boolean>,
      votingBalanceProofs: IVotingMachineWithProofs.VotingBalanceProofStruct[],
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    DATA_WAREHOUSE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    GOVERNANCE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    NAME(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    REPRESENTATIVES_SLOT(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    VOTE_SUBMITTED_BY_REPRESENTATIVE_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    VOTE_SUBMITTED_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    VOTING_ASSET_WITH_SLOT_RAW(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    VOTING_ASSET_WITH_SLOT_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    VOTING_STRATEGY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    closeAndSendVote(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getProposalById(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getProposalState(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getProposalVoteConfiguration(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getProposalsVoteConfigurationIds(
      skip: PromiseOrValue<BigNumberish>,
      size: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getUserProposalVote(
      user: PromiseOrValue<string>,
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    startProposalVote(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    submitVote(
      proposalId: PromiseOrValue<BigNumberish>,
      support: PromiseOrValue<boolean>,
      votingBalanceProofs: IVotingMachineWithProofs.VotingBalanceProofStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    submitVoteAsRepresentative(
      proposalId: PromiseOrValue<BigNumberish>,
      support: PromiseOrValue<boolean>,
      voter: PromiseOrValue<string>,
      proofOfRepresentation: PromiseOrValue<BytesLike>,
      votingBalanceProofs: IVotingMachineWithProofs.VotingBalanceProofStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    submitVoteAsRepresentativeBySignature(
      proposalId: PromiseOrValue<BigNumberish>,
      voter: PromiseOrValue<string>,
      representative: PromiseOrValue<string>,
      support: PromiseOrValue<boolean>,
      proofOfRepresentation: PromiseOrValue<BytesLike>,
      votingBalanceProofs: IVotingMachineWithProofs.VotingBalanceProofStruct[],
      signatureParams: IVotingMachineWithProofs.SignatureParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    submitVoteBySignature(
      proposalId: PromiseOrValue<BigNumberish>,
      voter: PromiseOrValue<string>,
      support: PromiseOrValue<boolean>,
      votingBalanceProofs: IVotingMachineWithProofs.VotingBalanceProofStruct[],
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
